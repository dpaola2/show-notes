# OPML Import - Discovery Report

> **Generated by:** Pipeline Stage 1 (Discovery)
> **Date:** 2026-02-07
> **PRD:** `opml-import/prd.md`

---

## 1. PRD Understanding

### Feature Summary
A one-time onboarding flow where new users upload an OPML file exported from their podcast app, select favorites from the imported list, and have the latest episode from each favorite processed in the background — so their first daily digest email arrives the next morning with real content. The primary entry point is the dashboard (inbox) empty state; a secondary entry point lives in Settings. Re-import is allowed (skips duplicates). No feature flag.

### Entities Identified
| Entity | PRD Reference | Existing? | Current Location |
|--------|--------------|-----------|-----------------|
| Podcast | SUB-001, IMP-004, IMP-005 | Yes | `app/models/podcast.rb` |
| Subscription | SUB-001, SUB-003 | Yes | `app/models/subscription.rb` |
| Episode | PRC-001 | Yes | `app/models/episode.rb` |
| UserEpisode | PRC-001, PRC-003 | Yes | `app/models/user_episode.rb` |
| User | FAV-001 | Yes | `app/models/user.rb` |
| OPML Parser (service) | IMP-004 | No | N/A — new service needed |
| Import flow (controller) | IMP-001 through IMP-007 | No | N/A — new controller/route needed |

### Platforms Affected
- [x] Rails (Web)
- [ ] Rails (API)
- [ ] iOS
- [ ] Android

---

## 2. Current State: Primary Platform

### Related Models

| Model | File | Key Associations | Notes |
|-------|------|------------------|-------|
| Podcast | `app/models/podcast.rb` | `has_many :subscriptions`, `has_many :users, through: :subscriptions`, `has_many :episodes` | Validates `guid` (unique), `title`, `feed_url`. Has `artwork_url` column. |
| Subscription | `app/models/subscription.rb` | `belongs_to :user`, `belongs_to :podcast` | Uniqueness constraint on `[user_id, podcast_id]`. Join table only — no extra columns. |
| Episode | `app/models/episode.rb` | `belongs_to :podcast`, `has_many :user_episodes`, `has_one :transcript`, `has_one :summary` | Validates `guid` (unique), `title`, `audio_url`. Has `estimated_cost_cents` method. |
| UserEpisode | `app/models/user_episode.rb` | `belongs_to :user`, `belongs_to :episode` | Location enum (`inbox/library/archive/trash`), processing_status enum. `move_to_library!` triggers processing. |
| User | `app/models/user.rb` | `has_many :subscriptions`, `has_many :podcasts, through: :subscriptions`, `has_many :user_episodes` | Magic link auth. `digest_enabled` flag. |
| Summary | `app/models/summary.rb` | `belongs_to :episode` | Stores `sections` (JSON) and `quotes` (JSON). |
| Transcript | `app/models/transcript.rb` | `belongs_to :episode` | Stores `content` (text, JSON from AssemblyAI). |

### Current Schema (Related Tables)

```ruby
# podcasts
create_table "podcasts" do |t|
  t.string "artwork_url"
  t.string "author"
  t.text "description"
  t.string "feed_url"          # No uniqueness index!
  t.string "guid"              # Unique index. Currently stores Podcast Index API feed ID.
  t.datetime "last_fetched_at"
  t.string "title"
  t.index ["guid"], unique: true
end

# subscriptions
create_table "subscriptions" do |t|
  t.bigint "podcast_id", null: false
  t.bigint "user_id", null: false
  t.index ["user_id", "podcast_id"], unique: true
end

# episodes
create_table "episodes" do |t|
  t.string "audio_url"
  t.text "description"
  t.integer "duration_seconds"
  t.string "guid"              # Unique index. From RSS feed <guid> element.
  t.bigint "podcast_id", null: false
  t.datetime "published_at"
  t.string "title"
  t.index ["guid"], unique: true
  t.index ["podcast_id"]
end

# user_episodes
create_table "user_episodes" do |t|
  t.bigint "episode_id", null: false
  t.datetime "last_error_at"
  t.integer "location", default: 0          # enum: inbox=0, library=1, archive=2, trash=3
  t.datetime "next_retry_at"
  t.text "processing_error"
  t.integer "processing_status", default: 0  # enum: pending=0..error=5
  t.integer "retry_count", default: 0
  t.datetime "trashed_at"
  t.bigint "user_id", null: false
  t.index ["user_id", "episode_id"], unique: true
end

# users
create_table "users" do |t|
  t.boolean "digest_enabled", default: true
  t.datetime "digest_sent_at"
  t.string "email"
  t.string "magic_token"
  t.datetime "magic_token_expires_at"
  t.index ["email"], unique: true
end
```

### Related Controllers

| Controller | File | Actions | Auth Pattern |
|-----------|------|---------|--------------|
| PodcastsController | `app/controllers/podcasts_controller.rb` | `index` (search), `show`, `create` (subscribe), `destroy` (unsubscribe) | `before_action :require_authentication` (from ApplicationController) |
| SubscriptionsController | `app/controllers/subscriptions_controller.rb` | `index` (list user's subscriptions) | Same |
| InboxController | `app/controllers/inbox_controller.rb` | `index`, `create`, `add_to_library`, `skip`, `clear` | Same |
| SettingsController | `app/controllers/settings_controller.rb` | `show`, `update` | Same |
| ApplicationController | `app/controllers/application_controller.rb` | Base class. Includes `Pagy::Method`. `before_action :require_authentication`. `current_user` helper. | Session-based (`session[:user_id]`) |

### Related Services

| Service | File | Purpose | Notes |
|---------|------|---------|-------|
| PodcastFeedParser | `app/services/podcast_feed_parser.rb` | Fetches and parses RSS feed XML → extracts episodes | Uses Feedjira. Returns array of `Episode` structs. Does NOT extract podcast metadata (title, artwork) — only episode data. |
| PodcastIndexClient | `app/services/podcast_index_client.rb` | Searches Podcast Index API for podcasts, fetches podcast details | `search(query)`, `podcast(feed_id)`, `episodes(feed_id)`. Auth via API key/secret. |
| AssemblyAiClient | `app/services/assembly_ai_client.rb` | Transcribes audio via AssemblyAI API | Used by ProcessEpisodeJob. |
| ClaudeClient | `app/services/claude_client.rb` | Summarizes transcripts via Claude API | Used by ProcessEpisodeJob. `summarize_chunked` method. |

### Related API Endpoints (Current)
N/A — Level 2 (web-only) project. No external API endpoints affected.

### Related Tests

| Test File | Coverage | Type |
|-----------|----------|------|
| `spec/models/podcast_spec.rb` | Validations, associations | Model |
| `spec/models/subscription_spec.rb` | Validations, associations, uniqueness | Model |
| `spec/models/episode_spec.rb` | Validations, associations, `estimated_cost_cents` | Model |
| `spec/models/user_episode_spec.rb` | Validations, enums, scopes, `move_to_*` methods | Model |
| `spec/models/user_spec.rb` | Validations, magic token methods | Model |
| `spec/requests/podcasts_spec.rb` | Search, subscribe, unsubscribe flows | Request |
| `spec/requests/inbox_spec.rb` | Inbox actions (add to library, skip, clear) | Request |
| `spec/requests/settings_spec.rb` | Show and update settings | Request |
| `spec/services/podcast_feed_parser_spec.rb` | Feed parsing, episode extraction, edge cases | Service |
| `spec/services/podcast_index_client_spec.rb` | API search, podcast lookup, error handling | Service |
| `spec/jobs/send_daily_digest_job_spec.rb` | Digest delivery logic, skip conditions | Job |
| `spec/jobs/refresh_all_feeds_job_spec.rb` | Feed refresh scheduling | Job |
| `spec/mailers/digest_mailer_spec.rb` | Daily digest email content and delivery | Mailer |

### Related Background Jobs

| Job | File | Purpose | Notes |
|-----|------|---------|-------|
| FetchPodcastFeedJob | `app/jobs/fetch_podcast_feed_job.rb` | Fetches RSS feed and creates Episode records for subscribers | On `initial_fetch: true`, limits to 10 most recent episodes. Creates UserEpisode (inbox) for each subscriber. |
| ProcessEpisodeJob | `app/jobs/process_episode_job.rb` | Transcribes + summarizes a single episode | Takes `user_episode_id`. Checks if already processed (reuses transcript/summary). Exponential backoff on rate limit. |
| RefreshAllFeedsJob | `app/jobs/refresh_all_feeds_job.rb` | Enqueues FetchPodcastFeedJob for all podcasts with subscribers | Runs hourly (production). |
| SendDailyDigestJob | `app/jobs/send_daily_digest_job.rb` | Sends digest email to users with inbox or recent library content | Runs daily at 12 PM UTC (7 AM Eastern). Skips users with no content. |

---

## 3. Current State: iOS

N/A — Level 2 (web-only) project.

---

## 4. Current State: Android

N/A — Level 2 (web-only) project.

---

## 5. Cross-Platform Patterns

### Data Flow

```
User subscribes → PodcastsController#create
  → Podcast.find_or_create_by!(guid: api_feed_id)
  → Subscription.create!
  → FetchPodcastFeedJob.perform_later(podcast_id, initial_fetch: true)
    → PodcastFeedParser.parse(feed_url) → Episode structs
    → Episode.find_or_initialize_by(guid:) → Episode.save!
    → UserEpisode.create!(location: :inbox) for each subscriber

User processes episode → InboxController#add_to_library
  → user_episode.move_to_library!
  → ProcessEpisodeJob.perform_later(user_episode_id)
    → AssemblyAiClient.transcribe → Transcript
    → ClaudeClient.summarize_chunked → Summary
    → user_episode.update!(processing_status: :ready)

Next morning → SendDailyDigestJob
  → DigestMailer.daily_digest(user)
  → Includes inbox episodes + recently processed library episodes
```

### How Podcasts Are Currently Created

The current subscription flow goes through PodcastIndex API:
1. User searches via `PodcastsController#index` → `PodcastIndexClient.search(query)` → returns API results
2. User clicks "Subscribe" → `PodcastsController#create` → `fetch_podcast_from_api(feed_id)` → `PodcastIndexClient.podcast(feed_id)`
3. Podcast created with `guid` = Podcast Index API's numeric feed ID (e.g., `"12345"`)
4. `artwork_url`, `author`, `description`, `feed_url` all come from the Podcast Index API response

**This is significant for OPML import:** OPML files contain `xmlUrl` (the RSS feed URL) and `text`/`title` (the podcast name). They do NOT contain Podcast Index feed IDs. This creates a guid mismatch — podcasts created via search have a numeric guid from Podcast Index, while OPML-imported podcasts would need a different guid strategy.

### How Episodes Are Created

`FetchPodcastFeedJob` parses the RSS feed via `PodcastFeedParser` and creates `Episode` records with `guid` from the RSS `<guid>` element. On initial fetch, only the 10 most recent episodes are added. Each episode gets a `UserEpisode` (inbox) for every subscriber.

### How Processing Works

`ProcessEpisodeJob` is a two-step pipeline:
1. Transcribe via AssemblyAI (downloads audio → returns transcript)
2. Summarize via Claude (processes transcript → returns sections + quotes)

If another user already processed the same episode, the transcript and summary are reused. Cost is estimated at ~$0.46/episode ($0.065/sec transcription + ~$0.10 summarization).

### Cost Estimation

`Episode#estimated_cost_cents` calculates: `(duration_seconds * 0.065).ceil + 10`. This is already used in the inbox view with `format_cost_cents()` helper and color-coded badges.

### How the Dashboard (Inbox) Works

Root route (`/`) maps to `inbox#index`. The inbox view has an empty state:
```erb
<p class="text-gray-500 mb-4">Your inbox is empty. Subscribe to podcasts to see new episodes here.</p>
<%= link_to "Find Podcasts", podcasts_path, class: "text-blue-600 hover:underline font-medium py-2 inline-block" %>
```
This is where the primary "Import your podcasts" CTA would go per the PRD.

### How Settings Works

`SettingsController` is simple: `show` and `update` with `permit(:digest_enabled)`. The settings page has two sections: "Email Preferences" and "Account". A new "Import" section would fit naturally here.

### UI Patterns

- Tailwind utility classes throughout
- Cards: `bg-white rounded-lg shadow border border-gray-200 p-4`
- Buttons: `bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition`
- Layout: `max-w-4xl mx-auto px-4 py-6 sm:py-8`
- Flash messages: auto-dismiss via `flash_controller.js` (Stimulus)
- Navigation: horizontal nav bar with icon + text, active state highlighting
- Podcast artwork: 16x16 / 20x20 rounded images with gray placeholder SVG fallback
- Existing artwork display pattern in `_podcast_result.html.erb` and `subscriptions/index.html.erb`

### Gems Available

- **Feedjira** — already in Gemfile, used by `PodcastFeedParser`. Can parse OPML as well as RSS.
- **Pagy** — pagination, used in inbox/library.
- No OPML-specific gem currently installed.

---

## 6. Technical Risks

| Risk | Severity | Details | Mitigation |
|------|----------|---------|------------|
| **GUID mismatch between subscribe and import paths** | High | Current subscribe path sets `podcast.guid` = Podcast Index numeric ID. OPML import has no Podcast Index ID — only a feed URL. If the same podcast is added via both paths, it creates duplicate Podcast records. | Architecture must define a consistent guid strategy. Options: (a) use feed_url as guid for OPML imports, (b) look up feed_url via Podcast Index API to get the numeric ID, (c) add a `feed_url` uniqueness index and use it for dedup alongside guid. |
| **No uniqueness index on `podcasts.feed_url`** | Med | Two Podcast records can exist for the same RSS feed URL. This means OPML re-import can't simply `find_or_create_by(feed_url:)` without risking duplicates from the search-subscribe path. | Add a uniqueness index on `feed_url`, or use a lookup strategy that checks both `guid` and `feed_url`. |
| **OPML parsing not built-in** | Low | No OPML parser exists in the codebase. OPML is simple XML (nested `<outline>` elements with `xmlUrl` and `text` attributes), but edge cases exist (nested folders, non-podcast outlines, multiple URL attributes). | Build a simple OPML parser service. Consider using Nokogiri (already a Rails transitive dependency) for XML parsing. |
| **Bulk feed fetching cost** | Med | OPML import triggers `FetchPodcastFeedJob` for each of 15-30 podcasts. Each job does an HTTP fetch. On `initial_fetch: true`, each creates up to 10 episodes in the inbox. With 25 feeds, that's 25 HTTP requests + up to 250 inbox items. | The PRD says "no backlog import" — only subscribe and start polling. The favorites path creates UserEpisodes only for selected podcasts' latest episodes. Non-favorites just get subscribed (polling starts, but no immediate episode creation needed). |
| **AI processing cost for favorites** | Low | Already mitigated by PRD design: user selects 5-10 favorites, sees cost estimate, confirms. `Episode#estimated_cost_cents` and `format_cost_cents` helper already exist. | Reuse existing cost estimation. Sum `estimated_cost_cents` across selected episodes for the total estimate. |
| **FetchPodcastFeedJob always creates inbox items for ALL subscribers** | Med | Current `FetchPodcastFeedJob` creates `UserEpisode` (inbox) for every subscriber. For OPML import, we want favorites' latest episodes to skip inbox and go directly to library for processing. Non-favorites should just subscribe without creating inbox entries immediately. | Import flow should not use `FetchPodcastFeedJob` with `initial_fetch: true` for all feeds. Instead: (a) create Podcast + Subscription records, (b) for favorites only, fetch the latest episode and create a UserEpisode in library state, then enqueue ProcessEpisodeJob. |
| **PodcastFeedParser doesn't extract podcast metadata** | Low | `PodcastFeedParser` extracts episodes only, not podcast-level metadata (title, artwork, description). For OPML import, we need to parse the RSS feed to get artwork_url, author, etc. since we're not going through PodcastIndex API. | Either extend PodcastFeedParser to optionally return podcast metadata, or extract it separately from the parsed Feedjira feed object. |

### Performance Concerns
- 25-30 concurrent `FetchPodcastFeedJob`s on import could saturate the Solid Queue worker. Since this runs in-process via Puma, it shares resources. Not a concern for a single-user app, but worth noting.
- No N+1 risk in the import flow itself — it's a write-heavy operation.

### Security Concerns
- File upload needs validation: OPML files are XML. Must not accept arbitrary large files. Standard Rails file upload limits apply.
- No cross-tenant risk (single-user app).

---

## 7. Open Questions

| # | Question | Source | Blocking? |
|---|----------|--------|-----------|
| 1 | How should `podcast.guid` be set for OPML-imported podcasts? The current path uses Podcast Index's numeric ID, but OPML files don't have that. If someone subscribes via search AND imports the same podcast via OPML, should those resolve to one Podcast record? | Schema: `podcasts.guid` is unique; `PodcastsController#find_or_create_podcast` uses API ID as guid | Yes — architecture must resolve this |
| 2 | Should PodcastFeedParser be extended to extract podcast-level metadata (title, artwork_url, author), or should a separate service handle this? | `app/services/podcast_feed_parser.rb` — currently returns only episodes | No |
| 3 | OPML files sometimes contain non-podcast feeds (blog RSS, news feeds). Should the parser attempt to filter these out, or import everything and let the feed fetch job sort it out? | PRD edge case: "OPML file contains feeds that can't be resolved" | No |
| 4 | The inbox empty state currently links to "Find Podcasts." The PRD wants an "Import your podcasts" CTA. Should this replace the existing link, or appear alongside it? What about users who have zero subscriptions but a non-empty inbox (edge case: subscribed via search, unsubscribed, episodes still in inbox)? | `app/views/inbox/index.html.erb:64-67` | No |

---

## 8. Recommendations for Architecture Stage

- **The guid dedup problem is the critical architecture decision.** The current `Podcast.guid` stores a Podcast Index API ID, but OPML imports only have feed URLs. Architecture must choose between: (a) normalizing guid to feed_url for all podcasts, (b) adding a `feed_url` uniqueness index and using both columns for lookup, or (c) looking up OPML feed URLs against the Podcast Index API to get numeric IDs (adds API dependency + latency to import).
- **Follow the existing subscription pattern** in `PodcastsController#create`: `find_or_create_by` for Podcast, `find_or_initialize_by` for Subscription. Extend this for bulk operations.
- **Reuse `PodcastFeedParser`** for fetching the latest episode from favorite podcasts. It already handles RSS parsing, episode extraction, duration parsing, and error handling.
- **Reuse `ProcessEpisodeJob`** for processing favorites. It already handles transcription, summarization, retries, and deduplication (checks if transcript/summary already exist).
- **Reuse `Episode#estimated_cost_cents`** and `ApplicationHelper#format_cost_cents` for the cost estimate display. Sum across selected episodes.
- **Build a lightweight OPML parser service** using Nokogiri (already available as a transitive dep). OPML is simple: `<outline>` elements with `xmlUrl` (feed URL) and `text` (title) attributes.
- **The import flow should be a multi-step controller** (upload → parse → select favorites → confirm). Since no mid-flow persistence is needed (per PRD), the parsed data can live in the form/session for the duration of the flow.
- **Don't use FetchPodcastFeedJob for the initial fetch** of favorites. Instead, fetch the feed inline (or via a dedicated import job), grab only the latest episode, create it in library state, and enqueue `ProcessEpisodeJob`. This avoids dumping 10 episodes per feed into the inbox.
- **The dashboard empty state** in `inbox/index.html.erb` (line 64) is the natural place for the primary CTA. The Settings page (`settings/show.html.erb`) can add a third section for "Import Podcasts."
- **Tailwind patterns are well-established** — follow existing card, button, and layout conventions.
