# Long-Lived Authentication — Architecture Proposal

> **Generated by:** Pipeline Stage 2 (Architecture)
> **Date:** 2026-02-08
> **PRD:** `long-lived-authentication/prd.md`
> **Discovery Report:** `long-lived-authentication/discovery-report.md`

---

## 1. Data Model Changes

### New Tables

None. This feature requires no new database tables.

### Modified Tables

None. No schema changes to any existing tables.

### Rails Models

No model changes. The `User` model remains unchanged — magic token methods (`generate_magic_token!`, `clear_magic_token!`, `magic_token_valid?`) are unaffected.

### Associations Map

No changes to the associations graph.

### Migration Plan

No migrations required. This is a pure configuration + controller logic change.

### Expected Data Volumes

N/A — no new data stored.

---

## 2. API Endpoints

No API endpoints are created or modified. This feature is entirely web-session-based.

### Modified Endpoints

None.

### Serializers

N/A.

---

## 3. Configuration Changes

This is the core of the feature. Two changes:

### 3a. Session Store Configuration

**File:** `config/initializers/session_store.rb` (new file)

```ruby
Rails.application.config.session_store :cookie_store,
  expire_after: 1.year
```

**What this does:**
- Sets the `Expires` / `Max-Age` attribute on the session cookie
- With `expire_after`, the cookie persists across browser restarts
- Without it (the current state), the cookie is a "session cookie" — deleted when the browser closes
- The cookie remains encrypted via Rails' `secret_key_base` (unchanged)
- `force_ssl: true` in production already ensures the `Secure` flag is set
- Rails 8.1 defaults `HttpOnly: true` and `SameSite: Lax`

**Why 1 year:**
- Single-user personal app — long lifetime is appropriate
- Re-authentication only needed if: cookies are cleared, user logs out, or secret key is rotated
- Annual re-auth is a reasonable safety net without being annoying
- The session cookie is encrypted and tamper-proof via Rails' cookie encryption

**Why a separate initializer (not inline in `application.rb`):**
- Follows Rails convention — session store config goes in its own initializer
- Consistent with how the app already separates config into initializers (`resend.rb`, `pagy.rb`, etc.)

### 3b. Return-To URL (DIG-002)

**Files modified:** `app/controllers/application_controller.rb`, `app/controllers/sessions_controller.rb`

#### ApplicationController — store requested URL before redirecting to login

```ruby
# app/controllers/application_controller.rb
def require_authentication
  unless current_user
    session[:return_to] = request.original_url if request.get?
    redirect_to login_path, alert: "Please sign in to continue"
  end
end
```

**Key detail:** Only store for GET requests. POST/PATCH/DELETE requests should not be replayed after auth — storing those URLs would lead to confusing behavior (e.g., replaying a form submission).

#### SessionsController#verify — redirect to stored URL after successful auth

```ruby
# app/controllers/sessions_controller.rb
def verify
  token = params[:token]

  if token.blank?
    redirect_to login_path, alert: "Invalid or missing token"
    return
  end

  user = User.find_by(magic_token: token)

  if user&.magic_token_valid?(token)
    user.clear_magic_token!
    session[:user_id] = user.id
    redirect_to session.delete(:return_to) || root_path, notice: "Welcome back!"
  else
    redirect_to login_path, alert: "This link has expired or is invalid. Please request a new one."
  end
end
```

**Key details:**
- `session.delete(:return_to)` atomically reads and clears the stored URL — prevents stale redirects on subsequent logins
- Falls back to `root_path` if no stored URL (same behavior as today)
- The stored URL persists in the session cookie, so it survives the email roundtrip (user enters email → receives magic link → clicks it → redirect to original page)
- Uses `request.original_url` (full URL with host) which `redirect_to` handles correctly for same-host redirects

#### Security consideration: open redirect prevention

`request.original_url` is always the current app's host (set by the request itself), so it can't be an attacker-supplied external URL. Additionally, `redirect_to` with `allow_other_host: false` (the Rails 8.1 default) will raise if the stored URL points to a different host. No additional validation needed.

---

## 4. Backwards Compatibility

### Compatibility Matrix

| Feature / Behavior | Web (current) | iOS | Android |
|-------------------|:---:|:---:|:---:|
| Session persists across browser restart | New — sessions now persist for 1 year | N/A | N/A |
| Magic link login flow | Unchanged | N/A | N/A |
| Digest email tracking links | Unchanged (no auth) | N/A | N/A |
| Post-auth redirect to original page | New — redirects to stored URL instead of always `/` | N/A | N/A |
| Logout behavior | Unchanged — `session.delete(:user_id)` | N/A | N/A |

### Old Client Behavior

N/A — Level 1 project, web only, no mobile clients affected.

### API Versioning

N/A — no API changes.

### Data Migration

None. Existing session cookies (if any active at deploy time) will be replaced by new cookies with the `Expires` attribute on next request. The user will need to re-authenticate once after deploy — acceptable for single-user app.

---

## 5. Security Design

### Query Scoping

No new data access paths. `current_user` continues to read `session[:user_id]` — unchanged.

### Authorization

No changes to authorization. The `before_action :require_authentication` pattern is unchanged — it still checks `current_user` and redirects if nil.

### New Attack Surface

| Vector | Risk | Mitigation |
|--------|------|------------|
| Long-lived cookie theft | Low — attacker with cookie access gets 1-year session | `force_ssl: true` prevents network sniffing. `HttpOnly: true` prevents XSS cookie theft. `SameSite: Lax` prevents CSRF. Encrypted cookie prevents tampering. Acceptable risk for single-user app. |
| Open redirect via `session[:return_to]` | None — `request.original_url` is always same-host, and `redirect_to` defaults to `allow_other_host: false` in Rails 8.1 | Built-in Rails protection. No additional validation needed. |
| Session fixation | None — Rails regenerates session ID on `session[:user_id] =` assignment | Built-in Rails protection. |

---

## 6. Export Impact

None. No exports affected.

---

## 7. Open Questions for Human Review

| # | Question | Options | Recommendation |
|---|----------|---------|---------------|
| 1 | Session lifetime: 1 year vs forever | A: `expire_after: 1.year` — re-auth once/year as a safety net / B: No `expire_after` maximum, use a very large value like `20.years` — effectively "forever" | **A: 1 year.** Provides a safety net in case a device is lost/stolen. Annual re-auth is negligible friction. Easy to change later (single value in one file). |

---

## 8. Alternatives Considered

### Database-Backed Sessions

**Description:** Add a `sessions` table with token, user_id, device info, expires_at. Authenticate via token in a persistent cookie rather than Rails' encrypted session cookie.

**Pros:**
- Server-side revocation ("log out everywhere")
- Per-device session visibility (see which devices are logged in)
- Explicit session lifecycle management

**Cons:**
- Requires migration, new model, cleanup job for expired sessions
- More code to maintain for a single-user app
- Rails cookie store already provides encrypted, tamper-proof sessions
- "Log out everywhere" has near-zero value for single-user app

**Why rejected:** Over-engineering. The cookie-only approach solves the problem with a one-line config change. The added complexity of database sessions provides no meaningful benefit for a single-user personal app.

### "Remember Me" Checkbox on Login Form

**Description:** Add a checkbox to the login form. If checked, set a persistent cookie. If unchecked, use a session cookie (current behavior).

**Pros:**
- Gives user control over persistence per-login
- Standard UX pattern users understand

**Cons:**
- Adds UI complexity for a single-user app
- The user always wants persistence — the checkbox adds friction with no upside
- Requires passing state through the magic-link email flow (checkbox checked → token generated → link clicked → persistence applied)

**Why rejected:** Dave is the only user and always wants persistence. A checkbox adds friction to every login for no benefit. Persistence should be the default.

---

## 9. Summary

### Files to Create

| File | Purpose |
|------|---------|
| `config/initializers/session_store.rb` | Set `expire_after: 1.year` on cookie store |

### Files to Modify

| File | Changes |
|------|---------|
| `app/controllers/application_controller.rb` | Add `session[:return_to] = request.original_url if request.get?` in `require_authentication` |
| `app/controllers/sessions_controller.rb` | Change `redirect_to root_path` → `redirect_to session.delete(:return_to) \|\| root_path` in `verify` action |

### Total Scope

- 1 new file (3 lines)
- 2 modified files (~2 lines changed each)
- 0 migrations
- 0 new models
- 0 API changes

---

## Approval Checklist

> **This architecture proposal requires human review and approval before the gameplan is generated.**

### Reviewer: Dave
### Date: 2/8/2026
### Status: Approved

#### Must Verify
- [x] Session store configuration is correct (`expire_after: 1.year` on cookie store)
- [x] Return-to URL approach is sound (store in session, consume after verify, GET-only)
- [x] Backwards compatibility is handled (one-time re-auth after deploy is acceptable)
- [x] Security analysis is sufficient (open redirect, cookie theft, session fixation)
- [x] No conflicts with in-progress work or upcoming changes

#### Should Check
- [x] Session lifetime (1 year) is acceptable
- [x] No "remember me" checkbox is the right UX choice
- [x] No "log out everywhere" is acceptable

#### Notes
[Reviewer notes, modifications requested, or rejection reasons]
