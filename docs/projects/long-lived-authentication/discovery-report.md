# Long-Lived Authentication — Discovery Report

> **Generated by:** Pipeline Stage 1 (Discovery)
> **Date:** 2026-02-08
> **PRD:** `long-lived-authentication/prd.md`

---

## 1. PRD Understanding

### Feature Summary
Make auth sessions persist across browser restarts so the user doesn't re-enter email + wait for magic link every time the browser is closed. The primary pain point is digest email links: clicking a link in the daily digest currently bounces the user through an auth wall before they can see the episode. This is a cookie-store configuration change — no new models or migrations needed.

### Entities Identified
| Entity | PRD Reference | Existing? | Current Location |
|--------|--------------|-----------|-----------------|
| User | SES-001..005, SEC-001 | Yes | `app/models/user.rb` |
| Session (Rails cookie) | SES-001..003 | Yes (implicit) | Rails default cookie_store (no explicit config) |
| EmailEvent | DIG-001 | Yes | `app/models/email_event.rb` |

### Platforms Affected
- [x] Rails (Web)
- [ ] Rails (API)
- [ ] iOS
- [ ] Android

---

## 2. Current State: Primary Platform

### Related Models

| Model | File | Key Associations | Notes |
|-------|------|------------------|-------|
| User | `app/models/user.rb` | has_many :subscriptions, :podcasts (through), :user_episodes, :email_events | Magic token methods: `generate_magic_token!`, `clear_magic_token!`, `magic_token_valid?` |
| EmailEvent | `app/models/email_event.rb` | belongs_to :user, :episode | Tracks digest email opens/clicks via opaque tokens |

### Current Schema (Related Tables)

```sql
-- users
create_table "users", force: :cascade do |t|
  t.datetime "created_at", null: false
  t.boolean "digest_enabled", default: true, null: false
  t.datetime "digest_sent_at"
  t.string "email"
  t.string "magic_token"
  t.datetime "magic_token_expires_at"
  t.datetime "updated_at", null: false
  t.index ["email"], name: "index_users_on_email", unique: true
end
```

No session-related columns exist on users. Sessions are purely cookie-based.

### Related Controllers

| Controller | File | Actions | Auth Pattern |
|-----------|------|---------|--------------|
| SessionsController | `app/controllers/sessions_controller.rb` | new, create, sent, verify, destroy | `skip_before_action :require_authentication` on all actions. Uses `session[:user_id]` for login. |
| ApplicationController | `app/controllers/application_controller.rb` | — | `before_action :require_authentication` globally. `current_user` reads `session[:user_id]`. |
| TrackingController | `app/controllers/tracking_controller.rb` | click, pixel | `skip_before_action :require_authentication`. Redirects click to `episodes#show` (which requires auth). |
| SettingsController | `app/controllers/settings_controller.rb` | show, update | Standard auth (inherits `require_authentication`). Currently only manages `digest_enabled`. |
| EpisodesController | `app/controllers/episodes_controller.rb` | show | Standard auth. This is the destination after tracking click redirect — the auth wall trigger point. |

### Session Configuration (Current)

**No explicit session store configuration exists.** No `config/initializers/session_store.rb`. No session-related settings in `config/application.rb` or any environment file. The app uses the Rails 8.1 default:

- **Store:** `ActionDispatch::Session::CookieStore`
- **Cookie name:** `_show_notes_session` (Rails convention from app name)
- **Expiry:** None set → browser session cookie (dies on browser close)
- **Encryption:** Rails encrypted cookie (uses `secret_key_base` from credentials)
- **`force_ssl: true`** in production → cookie is automatically `Secure`

**Key finding:** The entire "session dies on browser close" problem is because there's no `expire_after` set. Rails cookie store defaults to a session cookie (no `Expires` header) when `expire_after` is nil.

### Authentication Flow (Current)

```
1. GET  /login              → SessionsController#new        → render login form
2. POST /login              → SessionsController#create     → find_or_create user, generate_magic_token!, send email
3. GET  /login/sent         → SessionsController#sent       → "check your email" page
4. GET  /auth/verify?token= → SessionsController#verify     → validate token, clear token, set session[:user_id]
5. DELETE /logout           → SessionsController#destroy    → session.delete(:user_id)
```

**Magic token details:**
- Token: `SecureRandom.urlsafe_base64(32)` — 32 bytes, URL-safe Base64 encoded (43 chars)
- Expiry: 15 minutes from generation
- One-time use: cleared after successful verification
- Stored directly on User model (no separate token table)

### Digest Email → Episode Flow (Current — the pain point)

```
1. User receives daily digest email
2. Clicks "Read summary" link → GET /t/:token (TrackingController#click, no auth)
3. TrackingController records click, redirects to /episodes/:id
4. EpisodesController#show requires auth → redirect to /login
5. User enters email → receives magic link email → clicks it → redirected to root (/)
6. User must manually navigate back to the episode
```

**Problem breakdown:**
- Step 4 is the auth wall — if the session cookie has expired (browser closed), user must re-authenticate
- Step 5-6: after re-auth, user lands on root (`/`), NOT back on the episode they originally clicked
- There is **no return_to / stored_location** mechanism — `require_authentication` redirects to `login_path` with no memory of the original request URL

### Related Serializers
N/A — no API endpoints involved.

### Related API Endpoints (Current)
N/A — this is a web-only, session-only feature.

### Related Tests

| Test File | Coverage | Type |
|-----------|----------|------|
| `spec/requests/sessions_spec.rb` | Full auth flow: login form, POST login (valid/blank/invalid email), magic link sent page, verify (valid/expired/invalid/blank token), logout, auth requirement redirect | Request |
| `spec/support/authentication_helpers.rb` | `sign_in(user)` (full flow) and `sign_in_as(user)` (stub) helpers | Support |

**Test helper details:**
- `sign_in(user)`: Full flow — POST login, reload token, GET verify. Used in session specs.
- `sign_in_as(user)`: Stub — `allow_any_instance_of(ApplicationController).to receive(:current_user).and_return(user)`. Used in other request specs for speed.

### Related Background Jobs
N/A — no background jobs are involved in session handling.

### Related Views

| View | File | Notes |
|------|------|-------|
| Login form | `app/views/sessions/new.html.erb` | Email input + "Send Magic Link" button. No "remember me" checkbox. Uses `sessions` layout. |
| Magic link sent | `app/views/sessions/sent.html.erb` | "Check your email" confirmation page |
| Magic link email (HTML) | `app/views/user_mailer/magic_link.html.erb` | "Sign in to Show Notes" with button + URL fallback |
| Settings page | `app/views/settings/show.html.erb` | Currently shows: Email Preferences (digest toggle), Account (email display), Import Podcasts link |

---

## 3. Current State: iOS

N/A — Level 1 project (web only).

---

## 4. Current State: Android

N/A — Level 1 project (web only).

---

## 5. Cross-Platform Patterns

### Data Flow
N/A — no API or cross-platform data flow involved.

### How Similar Features Are Built
This is a configuration change, not a feature build. The closest analog in the codebase is the `force_ssl` setting in `config/environments/production.rb` — a single-line Rails config that affects all requests.

---

## 6. Technical Risks

| Risk | Severity | Details | Mitigation |
|------|----------|---------|------------|
| Secret key rotation invalidates all sessions | Low | If `secret_key_base` is rotated, all encrypted cookies become unreadable. With long-lived sessions this affects more users (well, one user on multiple devices). | Acceptable for single-user app. Document that key rotation = re-auth on all devices. |
| Cookie replay after logout | Low | With cookie-only sessions, "logged out" cookie could theoretically be replayed if an attacker captured it before logout. Cookie store doesn't have server-side revocation. | Acceptable for single-user app. `force_ssl` in production prevents cookie sniffing. |
| Session data size | Low | Rails cookie store has a 4KB limit. Current session only stores `user_id` (integer) and sometimes `import_*` keys (temporary OPML import state). Well under limit. | No action needed. |

### Performance Concerns
None. This is a configuration change with zero query impact.

### Security Concerns
- **Production uses `force_ssl: true`** (`config/environments/production.rb:32`) — this automatically sets `Secure` flag on cookies, preventing transmission over plain HTTP. Good.
- **No `HttpOnly` or `SameSite` explicit config** — but Rails 8.1 defaults `HttpOnly: true` and `SameSite: Lax` for session cookies. Both are correct defaults.
- The cookie is encrypted using Rails' `secret_key_base` from credentials — SEC-001 (cryptographically secure tokens) is satisfied by the existing Rails encryption layer.

---

## 7. Open Questions

| # | Question | Source | Blocking? |
|---|----------|--------|-----------|
| 1 | ~~Should DIG-002 (return-to URL after auth) be in scope?~~ **Resolved: Yes, in scope (promoted to Must).** Code confirms there is **no** `return_to` mechanism today — `require_authentication` always redirects to `login_path` and after verify, user always lands on `root_path`. Implementing requires changes to `require_authentication` (store URL) and `SessionsController#verify` (redirect to stored URL). | PRD §3 DIG-002, `app/controllers/application_controller.rb:21`, `app/controllers/sessions_controller.rb:48` | No |
| 2 | What session lifetime? The PRD lists options (30d, 90d, 1y, forever). Code shows no existing preference. | PRD §11 Q2 | No — Architecture stage can suggest a default |
| 3 | The session layout (`layout "sessions"`) is used for login/sent pages. Is there a `sessions.html.erb` layout file? | `app/controllers/sessions_controller.rb:2` | No — cosmetic |

---

## 8. Recommendations for Architecture Stage

- **Primary change:** Add `config.session_store :cookie_store, expire_after: <duration>` — either in `config/application.rb` or a new `config/initializers/session_store.rb`
- **Follow existing pattern:** The production config already sets `force_ssl` and `assume_ssl` which govern cookie security. Session config fits naturally alongside these.
- **Return-to URL (DIG-002):** If in scope, implement via `session[:return_to]` in `require_authentication`, consume in `SessionsController#verify`. This is a standard Rails pattern — store the requested URL, redirect after auth, clear the stored URL.
- **No migration needed.** No new models needed. The User model, SessionsController, and ApplicationController need minimal changes (or none, for cookie-only `expire_after`).
- **Test changes:** Existing session specs should continue to pass. New specs should verify cookie persistence behavior and (if implemented) return-to redirect.
- **Avoid database-backed sessions** — overkill for single-user app, adds complexity with no proportional benefit.
