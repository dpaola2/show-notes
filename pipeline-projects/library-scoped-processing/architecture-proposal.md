---
pipeline_stage: 2
pipeline_stage_name: architecture
pipeline_project: "library-scoped-processing"
pipeline_started_at: "2026-02-17T08:28:01-0500"
pipeline_completed_at: "2026-02-17T08:28:32-0500"
pipeline_approved_at:
---

# Library-Scoped Processing — Architecture Proposal

> **Generated by:** Pipeline Stage 2 (Architecture)
> **Date:** 2026-02-17
> **PRD:** `pipeline-projects/library-scoped-processing/prd.md`
> **Discovery Report:** `pipeline-projects/library-scoped-processing/discovery-report.md`

---

## 1. Data Model Changes

### New Tables

None.

### Modified Tables

None. No schema changes are required — the existing `user_episodes` table already has the `location` and `processing_status` columns needed to support library-scoped queries.

### Models

No model changes. The relevant existing model code:

```ruby
# app/models/user_episode.rb (existing, no changes)
class UserEpisode < ApplicationRecord
  enum :location, { inbox: 0, library: 1, archive: 2, trash: 3 }
  enum :processing_status, { pending: 0, downloading: 1, transcribing: 2,
                              summarizing: 3, ready: 4, error: 5 }

  scope :in_library, -> { where(location: :library) }

  def move_to_library!
    update!(location: :library, processing_status: :pending, trashed_at: nil,
            retry_count: 0, next_retry_at: nil, processing_error: nil)
  end
end
```

### Migration Plan

No migrations needed.

### Expected Data Volumes

No change — the existing tables are unaffected. Query patterns change but data volumes do not.

---

## 2. API Endpoints

N/A — this project does not expose or modify an API. All changes are to backend jobs and mailers.

---

## 3. Backwards Compatibility

N/A — no backwards compatibility concerns. Single-platform web app with no external consumers.

---

## 4. Security Design

### Authorization

No new data access paths are introduced. All existing access patterns remain unchanged:

| Action | Current Auth | After Change |
|--------|-------------|-------------|
| Digest email query | Scoped to `user.id` via subscription join | Scoped to `user.id` via `user_episodes.user_id` — same or tighter |
| Feed fetch job | No user context (system job) | No change |
| Library add | `current_user.user_episodes` | No change |
| Library retry | `current_user.user_episodes.find(params[:id])` | No change |

### New Attack Surface

None. The changes narrow query scope (from all subscribed episodes to library episodes only), which reduces rather than expands attack surface.

---

## 5. Export Impact

N/A — no export impact.

---

## 6. Detailed Design

This section describes the exact changes needed, file by file.

### 6.1 DigestMailer — Library-Scoped Query

**Current behavior:** Queries all episodes from subscribed podcasts created after `digest_sent_at`.

**New behavior:** Queries library episodes for this user with `processing_status = ready` and `updated_at > digest_sent_at`.

The query appears in two places within `digest_mailer.rb` (class method for eager load, instance method for deliver_later fallback). Both must be updated identically.

**New query (replaces both occurrences):**

```ruby
since ||= user.digest_sent_at || 1.day.ago

episodes_by_show = Episode
  .joins(:user_episodes)
  .where(user_episodes: { user_id: user.id, location: :library, processing_status: :ready })
  .where("user_episodes.updated_at > ?", since)
  .includes(:podcast, :summary)
  .order("podcasts.title ASC, episodes.published_at DESC")
  .group_by(&:podcast)
```

Key differences from current query:
- Joins `user_episodes` instead of `subscriptions`
- Filters by `location: :library` and `processing_status: :ready`
- Time filter uses `user_episodes.updated_at` (proxy for "became ready") instead of `episodes.created_at`
- Still groups by podcast for template compatibility

**Why `user_episodes.updated_at` works as a readiness proxy:** When `ProcessEpisodeJob` completes, it calls `user_episode.update!(processing_status: :ready, ...)` — this sets `updated_at`. For a single-user app, this is precise enough. A dedicated `ready_at` column would be more explicit but adds a migration for no practical benefit.

**Subject line change (DIG-003):**

```ruby
# Before:
subject: "Your podcasts this morning — #{@episode_count} new episode#{'s' unless @episode_count == 1}"

# After:
subject: "Your library — #{@episode_count} episode#{'s' unless @episode_count == 1} ready"
```

**NullMail guard (line 29):** No change needed — it already returns `NullMail` when `episode_count` is zero, which handles DIG-004.

### 6.2 SendDailyDigestJob — Library-Scoped Eligibility Check

**Current `has_new_episodes?`:**

```ruby
def has_new_episodes?(user)
  since = user.digest_sent_at || 1.day.ago
  Episode
    .joins(podcast: :subscriptions)
    .where(subscriptions: { user_id: user.id })
    .where("episodes.created_at > ?", since)
    .exists?
end
```

**New `has_new_episodes?`:**

```ruby
def has_new_episodes?(user)
  since = user.digest_sent_at || 1.day.ago
  Episode
    .joins(:user_episodes)
    .where(user_episodes: { user_id: user.id, location: :library, processing_status: :ready })
    .where("user_episodes.updated_at > ?", since)
    .exists?
end
```

This keeps the method name and interface identical — only the query body changes.

### 6.3 FetchPodcastFeedJob — Remove Auto-Processing

Remove line 35 from `app/jobs/fetch_podcast_feed_job.rb`:

```ruby
# DELETE this line:
AutoProcessEpisodeJob.perform_later(episode.id)

# And the comment on line 34:
# Auto-process: enqueue transcription + summarization
```

The rest of the job stays intact. New episodes still create `Episode` records and `UserEpisode` inbox entries.

### 6.4 AutoProcessEpisodeJob — Remove

Delete `app/jobs/auto_process_episode_job.rb` and `spec/jobs/auto_process_episode_job_spec.rb`.

Rationale: The job has exactly one call site (FetchPodcastFeedJob line 35), which is being removed. Leaving dead code is confusing — it suggests the job is still used somewhere. Removing it cleanly communicates intent.

### 6.5 DetectStuckProcessingJob — Remove Episode Detection Block

Remove lines 19-29 (the Episode stuck detection block) from `app/jobs/detect_stuck_processing_job.rb`. Keep the UserEpisode block (lines 7-17) which is still needed for `ProcessEpisodeJob`.

**After change:**

```ruby
class DetectStuckProcessingJob < ApplicationJob
  queue_as :default

  STUCK_THRESHOLD = 30.minutes + 1.second

  def perform
    UserEpisode
      .where(processing_status: [ :transcribing, :summarizing ])
      .where("updated_at < ?", STUCK_THRESHOLD.ago)
      .find_each do |ue|
        ue.update!(
          processing_status: :error,
          processing_error: "Processing timed out after #{STUCK_THRESHOLD.inspect}",
          last_error_at: Time.current
        )
      end
  end
end
```

### 6.6 Digest `since` Race Protection

The current DigestMailer has a race condition guard (CLAUDE.md documents this): the `since` parameter is captured eagerly and passed through to `deliver_later` serialization, so that if `digest_sent_at` is bumped between scheduling and delivery, the original cutoff is preserved.

This pattern must be preserved with the new query. It already works — the `since` parameter flows through to both class and instance methods, and the new query uses `since` the same way. No architectural change needed.

---

## 7. Open Questions for Human Review

| # | Question | Options | Recommendation |
|---|----------|---------|---------------|
| 1 | Should we extract the library-ready query into a shared scope to avoid the 3-site duplication? | A: Extract to `Episode.library_ready_since(user, since)` scope / B: Keep inline in each location | **B: Keep inline.** The query appears in exactly 2 active locations after the change (DigestMailer class method + instance fallback). `has_new_episodes?` is nearly identical but uses `.exists?` instead of full load. Extracting adds indirection for minimal dedup. |

---

## 8. Alternatives Considered

### Extract Digest Query to a Scope

**Description:** Move the library-ready episodes query to `Episode.library_ready_since(user, since)` or `UserEpisode.ready_in_library_since(user, since)` to DRY up the 3 query sites.

**Pros:** Single source of truth for the query. Easier to change if the query evolves.

**Cons:** Adds a scope that's only used by the digest system. The `has_new_episodes?` call uses `.exists?` which is structurally different from the full query. Indirection makes the mailer harder to read.

**Why rejected:** The duplication is between a class method and its deliver_later fallback (an inherent pattern in this mailer's race-condition architecture). Extracting would fight the architecture rather than simplify it.

### Keep AutoProcessEpisodeJob as Dead Code

**Description:** Leave the job class in place but don't call it.

**Pros:** Zero risk of breaking anything. Easier to re-enable if the decision is reversed.

**Cons:** Dead code is confusing. Future developers (or agents) may think it's still active. The job has exactly one call site, so re-enabling is trivial even after deletion (just re-add the file).

**Why rejected:** Clean deletion is safer than dead code for a single-developer project. Git history preserves the code if needed.

---

## 9. Architecture Decision Records

No decisions in this project warranted a standalone ADR. The changes are behavioral (query changes, line deletions, file removal) with no genuinely contested architectural alternatives.

---

## 10. Summary

### Files to Create

None.

### Files to Modify

| File | Changes |
|------|---------|
| `app/mailers/digest_mailer.rb` | Replace subscription-scoped query with library-scoped query in both class and instance methods (lines 20-26, 80-86). Update subject line (line 105). |
| `app/jobs/send_daily_digest_job.rb` | Replace subscription-scoped `has_new_episodes?` query with library-scoped query (lines 37-44). |
| `app/jobs/fetch_podcast_feed_job.rb` | Remove `AutoProcessEpisodeJob.perform_later(episode.id)` call and comment (lines 34-35). |
| `app/jobs/detect_stuck_processing_job.rb` | Remove Episode stuck detection block (lines 19-29). |

### Files to Delete

| File | Reason |
|------|--------|
| `app/jobs/auto_process_episode_job.rb` | No longer called — dead code after FetchPodcastFeedJob change. |
| `spec/jobs/auto_process_episode_job_spec.rb` | Tests for removed job. |

### Test Files to Update

| File | Changes |
|------|---------|
| `spec/mailers/digest_mailer_spec.rb` | Update to verify library-only episode inclusion. |
| `spec/jobs/send_daily_digest_job_spec.rb` | Update to verify library-only eligibility check. |
| `spec/jobs/fetch_podcast_feed_job_spec.rb` | Remove AutoProcessEpisodeJob enqueue assertions. |
| `spec/jobs/detect_stuck_processing_job_spec.rb` | Remove Episode timeout detection tests. |

---

## Approval Checklist

> **This architecture proposal requires human review and approval before the gameplan is generated.**

### Reviewer:
### Date:
### Status: Pending

#### Must Verify
- [ ] Query change from subscription-scoped to library-scoped is correct (joins user_episodes, filters by location + processing_status + updated_at)
- [ ] Using `user_episodes.updated_at` as a proxy for "became ready" is acceptable
- [ ] Removing `AutoProcessEpisodeJob` entirely (rather than keeping as dead code) is acceptable
- [ ] Removing Episode stuck detection from `DetectStuckProcessingJob` is acceptable
- [ ] The `since` race protection pattern is preserved correctly

#### Should Check
- [ ] Subject line change ("Your library — N episodes ready") is the desired framing
- [ ] Keeping the digest query inline (not extracting to a scope) is acceptable
- [ ] No conflicts with in-progress work or upcoming changes

#### Notes
[Reviewer notes, modifications requested, or rejection reasons]
