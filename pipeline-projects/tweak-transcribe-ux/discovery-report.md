---
pipeline_stage: 1
pipeline_stage_name: discovery
pipeline_project: "tweak-transcribe-ux"
pipeline_started_at: "2026-02-09T19:20:09-0500"
pipeline_completed_at: "2026-02-09T19:22:00-0500"
---

# Transcription Resilience & Retry UX — Discovery Report

> **Generated by:** Pipeline Stage 1 (Discovery)
> **Date:** 2026-02-09
> **PRD:** `~/projects/show-notes/pipeline-projects/tweak-transcribe-ux/prd.md`

---

## 1. PRD Understanding

### Feature Summary

Fix gaps in transcription error handling where certain failure modes (particularly AssemblyAI rate limits during bulk OPML import) bypass existing error handling, leaving episodes permanently stuck in `transcribing`. Add concurrency throttling for bulk operations, extend error/retry UX to the Inbox tab (currently only in Library), and implement stuck-job timeout detection.

### Entities Identified

| Entity | PRD Reference | Existing? | Current Location |
|--------|--------------|-----------|-----------------|
| UserEpisode | ERR-001, INB-001, LIB-001 | Yes | `app/models/user_episode.rb` |
| Episode | ERR-001, THR-001 | Yes | `app/models/episode.rb` |
| Transcript | ERR-001 | Yes | `app/models/transcript.rb` |
| Summary | ERR-001 | Yes | `app/models/summary.rb` |
| ProcessEpisodeJob | ERR-001, THR-001, INB-003 | Yes | `app/jobs/process_episode_job.rb` |
| AutoProcessEpisodeJob | ERR-001, THR-002 | Yes | `app/jobs/auto_process_episode_job.rb` |
| AssemblyAiClient | ERR-003, THR-001 | Yes | `app/services/assembly_ai_client.rb` |
| OpmlImportService | THR-001 | Yes | `app/services/opml_import_service.rb` |
| FetchPodcastFeedJob | THR-002 | Yes | `app/jobs/fetch_podcast_feed_job.rb` |
| Stuck job detector | ERR-002 | No | N/A — new component needed |

### Platforms Affected

- [x] Rails (Web)
- [ ] Rails (API)
- [ ] iOS
- [ ] Android

---

## 2. Current State: Primary Platform

### Related Models

| Model | File | Key Associations | Notes |
|-------|------|------------------|-------|
| UserEpisode | `app/models/user_episode.rb` | belongs_to :user, belongs_to :episode | Processing state owner. Has `processing_status` enum, retry tracking fields. Delegates episode attributes. |
| Episode | `app/models/episode.rb` | belongs_to :podcast, has_one :transcript, has_one :summary, has_many :user_episodes | Content container. Shared across users. No processing state. |
| Transcript | `app/models/transcript.rb` | belongs_to :episode | Simple write-once model. `content` is JSON string. |
| Summary | `app/models/summary.rb` | belongs_to :episode | JSONB `sections` + `quotes`. `before_save` callback populates `searchable_text`. |

### Current Schema (Related Tables)

```ruby
# user_episodes — processing state lives here
create_table "user_episodes" do |t|
  t.bigint "episode_id", null: false
  t.bigint "user_id", null: false
  t.integer "location", default: 0, null: false          # enum: inbox(0), library(1), archive(2), trash(3)
  t.integer "processing_status", default: 0, null: false  # enum: pending(0), downloading(1), transcribing(2), summarizing(3), ready(4), error(5)
  t.integer "retry_count", default: 0, null: false
  t.datetime "next_retry_at"
  t.datetime "last_error_at"
  t.text "processing_error"
  t.datetime "trashed_at"
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
  # Indexes: [user_id, episode_id] UNIQUE, [user_id], [episode_id]
end

# episodes — content container, shared across users
create_table "episodes" do |t|
  t.bigint "podcast_id", null: false
  t.string "guid"
  t.string "title"
  t.text "description"
  t.string "audio_url"
  t.integer "duration_seconds"
  t.datetime "published_at"
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
  # Indexes: [podcast_id, guid] UNIQUE, [podcast_id]
end

# transcripts — one per episode, shared
create_table "transcripts" do |t|
  t.bigint "episode_id", null: false
  t.text "content"                       # JSON string of AssemblyAI response
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
end

# summaries — one per episode, shared
create_table "summaries" do |t|
  t.bigint "episode_id", null: false
  t.json "sections"                      # [{title, content}, ...]
  t.json "quotes"                        # [{text, start_time}, ...]
  t.text "searchable_text"               # Denormalized for search
  t.datetime "created_at", null: false
  t.datetime "updated_at", null: false
end
```

### Related Controllers

| Controller | File | Actions | Auth Pattern |
|-----------|------|---------|--------------|
| InboxController | `app/controllers/inbox_controller.rb` | index, create, add_to_library, skip, clear | `ApplicationController` (session-based, magic link) |
| LibraryController | `app/controllers/library_controller.rb` | index, show, archive, regenerate | `ApplicationController` |
| ImportsController | `app/controllers/imports_controller.rb` | new, create, select_favorites, process_favorites, complete | `ApplicationController` |

### Related Serializers

N/A — this is a web-only app with ERB views. No API serializers.

### Related API Endpoints (Current)

N/A — Level 2 web-only project. No API.

### Related Background Jobs

| Job | File | Purpose | Error Handling |
|-----|------|---------|----------------|
| ProcessEpisodeJob | `app/jobs/process_episode_job.rb` | Transcribe + summarize for a UserEpisode (Library pathway) | Catches `ClaudeClient::RateLimitError` + `AssemblyAiClient::Error` → retry with backoff. Catch-all `=> e` → sets `error` status. |
| AutoProcessEpisodeJob | `app/jobs/auto_process_episode_job.rb` | Transcribe + summarize for an Episode (Inbox/feed pathway) | Catches same exceptions → retry with backoff. Catch-all `=> e` → **logs only, no state tracking.** |
| FetchPodcastFeedJob | `app/jobs/fetch_podcast_feed_job.rb` | Fetches new episodes from podcast feeds, creates UserEpisode in inbox, enqueues AutoProcessEpisodeJob | **No error handling at all.** |
| RefreshAllFeedsJob | (recurring) | Enqueues FetchPodcastFeedJob for each podcast | Runs hourly (prod) / 15min (dev) |

### Related Services

| Service | File | Purpose | Error Handling |
|---------|------|---------|----------------|
| AssemblyAiClient | `app/services/assembly_ai_client.rb` | Transcription via AssemblyAI API | Wraps all errors as `AssemblyAiClient::Error`. **`RateLimitError` class defined but never raised** — no HTTP status inspection. |
| ClaudeClient | `app/services/claude_client.rb` | Summarization via Anthropic API | Detects rate limits via exception type AND message string parsing. Raises `ClaudeClient::RateLimitError`. |
| OpmlImportService | `app/services/opml_import_service.rb` | OPML import: subscribe + process favorites | `process_favorites` enqueues one `ProcessEpisodeJob` per podcast with **no throttling**. |

### Related Views

| View | File | Purpose | Processing Status Display |
|------|------|---------|--------------------------|
| Inbox index | `app/views/inbox/index.html.erb` | Episode triage (Add to Library / Skip) | **None** — no processing status shown |
| Library index | `app/views/library/index.html.erb` | Processed episodes list | Shows status via case statement: pending/downloading/transcribing/summarizing (yellow), ready (green), error (red text only — no error message or retry) |
| Library show | `app/views/library/show.html.erb` | Episode detail with summary | Full treatment: ready → summary + Regenerate button; error → red alert with `processing_error` + Retry button; processing → yellow alert with retry debug info |

### Related Routes

```ruby
# Inbox
resources :inbox, only: [:index, :create] do
  collection do
    post :add_to_library   # Moves episode to library, enqueues ProcessEpisodeJob
    post :skip             # Moves episode to trash
    delete :clear          # Moves all inbox episodes to trash
  end
end

# Library
resources :library, only: [:index, :show] do
  member do
    post :archive          # Moves to archive
    post :regenerate       # Resets to summarizing, re-enqueues ProcessEpisodeJob
  end
end

# OPML Import
resource :import, only: [:new, :create]
get  "import/select_favorites"
post "import/process_favorites"   # Triggers bulk ProcessEpisodeJob enqueue
get  "import/complete"
```

### Related Stimulus Controllers

| Controller | File | Purpose |
|-----------|------|---------|
| audio-player | `app/javascript/controllers/audio_player_controller.js` | Audio playback on library show page |
| audio-seek | `app/javascript/controllers/audio_seek_controller.js` | Click-to-seek on quotes |

No Stimulus controllers related to processing status, polling, or retry. Status updates require full page reload.

### Related Tests

| Test File | Coverage | Type |
|-----------|----------|------|
| `spec/jobs/auto_process_episode_job_spec.rb` | Transcription, summarization, skip-if-processed, retry logic, max retry limit | Job spec |
| `spec/jobs/fetch_podcast_feed_job_spec.rb` | Feed parsing, episode creation, UserEpisode creation, AutoProcessEpisodeJob enqueue | Job spec |
| `spec/services/opml_import_service_spec.rb` | subscribe_all, process_favorites, duplicates, error resilience, job enqueue | Service spec |
| `spec/requests/imports_spec.rb` | Full import flow, file validation, favorites selection, job enqueue | Request spec |
| `spec/requests/inbox_spec.rb` | Index, clear, pagination, empty state | Request spec |
| `spec/requests/library_spec.rb` | Index, pagination, empty state | Request spec |
| **`spec/jobs/process_episode_job_spec.rb`** | **DOES NOT EXIST** | **Missing** |

---

## 3. Current State: iOS

N/A — Level 2 (web-only) project.

---

## 4. Current State: Android

N/A — Level 2 (web-only) project.

---

## 5. Cross-Platform Patterns

### Data Flow

```
OPML Import / Feed Fetch
    ↓
Episode + UserEpisode created
    ↓
ProcessEpisodeJob or AutoProcessEpisodeJob enqueued (Solid Queue, :default queue)
    ↓
AssemblyAiClient.transcribe(audio_url) → Episode.create_transcript!
    ↓
ClaudeClient.summarize_chunked(transcript) → Episode.create_summary!
    ↓
UserEpisode.processing_status = :ready
```

**Key architectural pattern:** Transcript and Summary are Episode-level (shared). Processing status is UserEpisode-level (per-user). If User A processes an episode, User B gets it instantly without API calls.

### How Similar Features Are Built

**Regenerate flow (closest pattern):** `LibraryController#regenerate` (line 22-33) resets state and re-enqueues:
```ruby
user_episode.episode.summary&.destroy
user_episode.update!(processing_status: :summarizing, retry_count: 0, next_retry_at: nil, processing_error: nil)
ProcessEpisodeJob.perform_later(user_episode.id)
```

This is the pattern to follow for retry actions in both Inbox and Library.

### Solid Queue Configuration

- Jobs use `:default` queue
- Solid Queue runs in-process via Puma plugin (`plugin :solid_queue if ENV["SOLID_QUEUE_IN_PUMA"]`)
- **No concurrency controls configured** — `concurrency_key` column exists on `solid_queue_jobs` but is unused
- `solid_queue_semaphores` table exists (Solid Queue's native concurrency limiting mechanism) but is unused
- Solid Queue supports `limits_concurrency` at the job class level — this is the framework-native way to throttle

---

## 6. Technical Risks

| Risk | Severity | Details | Mitigation |
|------|----------|---------|------------|
| AssemblyAI rate limits wrapped as generic `Error` | **High** | `AssemblyAiClient::RateLimitError` is defined (line 3) but never raised. All failures become `AssemblyAiClient::Error`. Jobs can't distinguish rate limits from permanent failures. | Add HTTP 429 detection in `AssemblyAiClient`, raise `RateLimitError` specifically. |
| `AutoProcessEpisodeJob` has no state tracking | **High** | Catch-all on line 30-31 only logs to Rails logger. No `processing_status` update on any UserEpisode. Silent failure with no user visibility. | This job operates on Episode (not UserEpisode), so it has no status field to write to. Architecture needs to decide how to bridge this gap. |
| `FetchPodcastFeedJob` has zero error handling | **High** | No rescue blocks at all. If feed parsing fails mid-iteration, remaining episodes aren't created, and the error is unhandled. | Add rescue blocks, at minimum catch-and-continue per-episode. |
| No `ProcessEpisodeJob` spec file | **Med** | The job with the most complex error handling logic has zero direct test coverage. Only tested indirectly via service/controller specs that assert enqueue. | Stage 4 will need to create this spec. |
| `concurrency_key` unused on Solid Queue jobs | **Med** | All jobs run on `:default` queue with no concurrency limits. 100+ OPML favorites = 100+ concurrent AssemblyAI calls. | Solid Queue's `limits_concurrency` API provides native throttling. |
| Library index shows "Error" text without error message or retry | **Low** | `library/index.html.erb` line 26 shows `<span class="text-red-600">Error</span>` — no `processing_error` message, no retry button. User must click through to show page to see error details or retry. | Add error message and retry button to index listing. |
| `regenerate` action always sets status to `:summarizing` | **Low** | `LibraryController#regenerate` (line 27) sets `processing_status: :summarizing`, which is wrong if the transcript is also missing (e.g., transcription failed before creating transcript). `ProcessEpisodeJob` handles this correctly — it checks for transcript first — but the status shown to the user will be misleading. | Set to `:pending` instead, let the job determine the correct transitional status. |

### Performance Concerns

- **Concurrent API calls:** With no throttling, OPML import of N podcasts fires N `ProcessEpisodeJob`s immediately. Each makes a blocking AssemblyAI API call (transcription can take minutes per episode). With Solid Queue's default 3 Puma threads, actual parallelism is limited by thread count, but jobs pile up and may all encounter rate limits sequentially.
- **No index on `processing_status`:** Queries filtering by `processing_status` (e.g., finding stuck jobs) will scan the full `user_episodes` table. Acceptable for current scale but worth noting for the stuck-job detector.

### Security Concerns

- All controller actions scope queries through `current_user` — no cross-tenant risks.
- `InboxController#add_to_library` uses `current_user.user_episodes.find(params[:id])` — properly scoped.

---

## 7. Open Questions

| # | Question | Source | Status | Answer |
|---|----------|--------|--------|--------|
| 1 | How does the AssemblyAI SDK handle 429 responses? | `assemblyai-1.2.0/lib/requests.rb` | **Resolved** | SDK uses Faraday with `:raise_error` middleware. 429 → `Faraday::TooManyRequestsError` (subclass of `Faraday::Error`). Our `AssemblyAiClient` catches `Faraday::Error` on line 48 and wraps as `AssemblyAiClient::Error`. **Rate limits ARE caught and retried.** They don't cause stuck episodes. The real stuck-state cause may be the SDK's internal polling hanging, or silent job crashes. |
| 2 | How should `AutoProcessEpisodeJob` report errors? | `auto_process_episode_job.rb` | **Resolved** | Add error tracking at the Episode level (per user direction). Add `processing_status`, `processing_error`, `last_error_at` columns to `episodes` table. |
| 3 | Should `ProcessEpisodeJob` and `AutoProcessEpisodeJob` be unified? | Both job files | Open | Architecture decision. |
| 4 | What AssemblyAI plan/rate limits apply? | External | Open | Not blocking — useful for tuning throttle limits. |
| 5 | Should retry action reuse `regenerate` or need a new endpoint? | `library_controller.rb:22-33` | Open | `regenerate` sets `:summarizing` which is wrong if transcript is missing. Retry should use `:pending`. |

---

## 8. Recommendations for Architecture Stage

- **Solid Queue `limits_concurrency`** is the framework-native way to throttle jobs. It uses the existing `concurrency_key` and `semaphores` tables already in the schema. This should be the primary approach for THR-001/THR-002.
- **`AssemblyAiClient`** needs HTTP status inspection to distinguish 429 (rate limit) from other errors. The `RateLimitError` class already exists — it just needs to be raised.
- **`AutoProcessEpisodeJob` state tracking** is the biggest architectural question. The simplest approach: when auto-processing fails, update all UserEpisodes for that episode that are still in a processing state.
- **Inbox view** currently has zero processing status display. The Library index view (`library/index.html.erb:14-28`) has a case statement pattern to follow.
- **Library index** error display is minimal (just "Error" text). The Library show page (`library/show.html.erb:58-64`) has the full error treatment to reference.
- **Retry action from list views** needs a new endpoint or reuse of `regenerate`. Current `regenerate` always starts from `:summarizing` — a proper retry should reset to `:pending` and let the job figure out what to do.
- **Stuck job detection** could be a recurring Solid Queue job (already have the pattern in `recurring.yml`) that queries `user_episodes WHERE processing_status IN (transcribing, summarizing) AND updated_at < X`.
- **No schema changes expected** — all retry/error tracking columns already exist on `user_episodes`.
